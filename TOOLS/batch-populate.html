<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéµ Popula√ß√£o por Lotes - Karaoke Hub</title>
    <script src="../config.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .stat-card p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #56ab2f 0%, #a8e6cf 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        .log-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-info { background: #d1ecf1; color: #0c5460; }
        .log-success { background: #d4edda; color: #155724; }
        .log-warning { background: #fff3cd; color: #856404; }
        .log-error { background: #f8d7da; color: #721c24; }

        .credits-display {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .batch-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .batch-selector select {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 1em;
            background: white;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Karaoke Hub - Administra√ß√£o</h1>
            <p>Sistema de gerenciamento e expans√£o do banco de m√∫sicas</p>
        </div>

        <div class="credits-display" id="creditsDisplay">
            üí≥ Cr√©ditos Gastos: <span id="creditsUsed">0</span> | 
            üí∞ Restantes: <span id="creditsRemaining">60.000</span>
        </div>

        <!-- SE√á√ÉO PRINCIPAL: BUSCA DE CL√ÅSSICOS -->
        <div style="margin: 20px 0; padding: 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.1);">
            <div style="text-align: center; margin-bottom: 20px;">
                <h2 style="color: white; font-size: 1.6em; margin-bottom: 8px;">üé∏ Busca Autom√°tica de Cl√°ssicos</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 1em;">Adicione cl√°ssicos de diferentes d√©cadas e g√™neros automaticamente</p>
            </div>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div>
                    <label for="decadeSelect" style="display: block; font-weight: bold; margin-bottom: 6px; color: white;">üìÖ D√©cada:</label>
                    <select id="decadeSelect" style="width: 100%; padding: 10px; border-radius: 6px; border: none; font-size: 0.9em;">
                        <option value="1960s">Anos 60</option>
                        <option value="1970s">Anos 70</option>
                        <option value="1980s" selected>Anos 80</option>
                        <option value="1990s">Anos 90</option>
                        <option value="2000s">Anos 2000</option>
                    </select>
                </div>

                <div>
                    <label for="genreSelect" style="display: block; font-weight: bold; margin-bottom: 6px; color: white;">üéµ G√™nero:</label>
                    <select id="genreSelect" style="width: 100%; padding: 10px; border-radius: 6px; border: none; font-size: 0.9em;">
                        <option value="rock" selected>Rock</option>
                        <option value="sertanejo">Sertanejo</option>
                        <option value="romantico">Rom√¢ntico</option>
                        <option value="mpb">MPB</option>
                    </select>
                </div>

                <div>
                    <label for="quantitySelect" style="display: block; font-weight: bold; margin-bottom: 6px; color: white;">üî¢ Quantidade:</label>
                    <select id="quantitySelect" style="width: 100%; padding: 10px; border-radius: 6px; border: none; font-size: 0.9em;">
                        <option value="50" selected>50 m√∫sicas</option>
                        <option value="100">100 m√∫sicas</option>
                        <option value="200">200 m√∫sicas</option>
                        <option value="500">500 m√∫sicas</option>
                    </select>
                </div>
            </div>

            <div style="text-align: center; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button class="btn" id="searchClassicsBtn" style="background: rgba(255,255,255,0.2); color: white; padding: 12px 30px; font-size: 1.1em; border: 2px solid rgba(255,255,255,0.3);">
                    üé∏ Buscar Cl√°ssicos
                </button>
                <button class="btn" id="clearSessionCacheBtn" style="background: rgba(255,255,255,0.1); color: white; padding: 12px 25px; font-size: 0.95em; border: 2px solid rgba(255,255,255,0.2);">
                    üßπ Limpar Cache
                </button>
            </div>

            <div id="classicsProgress" style="margin-top: 15px; display: none;">
                <div style="background: rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden; margin-bottom: 8px;">
                    <div id="classicsProgressFill" style="height: 16px; background: rgba(255,255,255,0.8); width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="classicsProgressText" style="text-align: center; font-weight: bold; color: white; font-size: 0.9em;">Iniciando busca...</div>
            </div>
        </div>

        <!-- SE√á√ÉO SECUND√ÅRIA: POPULA√á√ÉO POR LOTES -->
        <details style="margin: 20px 0;">
            <summary style="padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; font-weight: bold; color: #333;">
                üì¶ Popula√ß√£o por Lotes (Avan√ßado)
            </summary>
            
            <div style="padding: 20px; background: #fff; border: 1px solid #ddd; border-top: none; border-radius: 0 0 8px 8px;">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3 id="totalAvailable">0</h3>
                        <p>M√∫sicas no Banco Expandido</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="totalBatches">0</h3>
                        <p>Lotes Dispon√≠veis</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="currentBatch">0</h3>
                        <p>Lote Selecionado</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="processedSongs">0</h3>
                        <p>Processadas na Sess√£o</p>
                    </div>
                </div>

                <div class="batch-selector">
                    <label for="batchSelect"><strong>Selecionar Lote:</strong></label>
                    <select id="batchSelect">
                        <option value="0">Lote 1 (M√∫sicas 1-100)</option>
                    </select>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="populateBatchBtn">
                        üöÄ Popular Lote Selecionado
                    </button>
                    <button class="btn btn-success" id="testConnectionBtn">
                        üîó Testar Conex√£o
                    </button>
                    <button class="btn btn-info" id="viewBatchBtn">
                        üëÅÔ∏è Visualizar Lote
                    </button>
                    <button class="btn btn-warning" id="clearLogBtn">
                        üßπ Limpar Log
                    </button>
                </div>
            </div>
        </details>

        <div class="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Aguardando in√≠cio...</div>
        </div>

        <div class="log-section">
            <div id="logContainer">
                <div class="log-entry log-info">
                    üéµ Sistema de Popula√ß√£o por Lotes iniciado - Pronto para expandir seu banco de m√∫sicas!
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <!-- Firebase SDK - Vers√£o atualizada para compatibilidade -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <!-- Banco Expandido -->
    <script src="../expand-music-database.js"></script>
    
    <!-- Sistema de Preven√ß√£o de Duplicatas -->
    <script src="../prevent-duplicates.js"></script>

    <script>
        // Verifica√ß√£o de senha de acesso
        function checkAccess() {
            const password = prompt('üîê Digite a senha de administrador para acessar as funcionalidades de expans√£o do banco:');
            
            if (!password) {
                alert('‚ùå Acesso negado! Esta p√°gina ser√° fechada.');
                window.close();
                return false;
            }
            
            const correctPasswordHash = 'karaoke2024'; // Senha: karaoke2024
            if (password !== correctPasswordHash) {
                alert('‚ùå Senha incorreta! Acesso negado. Esta p√°gina ser√° fechada.');
                window.close();
                return false;
            }
            
            return true;
        }
        
        // Verificar acesso antes de continuar
        if (!checkAccess()) {
            throw new Error('Acesso negado');
        }
        
        // Configura√ß√µes centralizadas - carregadas do config.js
        if (!window.YOUTUBE_API_KEYS || !window.firebaseConfig) {
            alert('‚ùå Configura√ß√µes n√£o encontradas! Verifique se o arquivo config.js est√° carregado e configurado corretamente.');
            throw new Error('Configura√ß√µes necess√°rias n√£o encontradas');
        }

        // YouTube API Configuration - Sistema de Rod√≠zio de Chaves
        // Usar diretamente window.YOUTUBE_API_KEYS para evitar redeclara√ß√£o

        let currentKeyIndex = 0;
        let keyUsageCount = {};

        // Inicializar contador de uso para cada chave
        window.YOUTUBE_API_KEYS.forEach((key, index) => {
            keyUsageCount[index] = 0;
        });

        // Fun√ß√£o para obter a pr√≥xima chave dispon√≠vel
        function getNextAPIKey() {
            // Converter objeto para array para usar map
            const keyUsageArray = Object.keys(keyUsageCount).map(index => ({
                index: parseInt(index),
                count: keyUsageCount[index]
            }));
            
            // Encontrar chaves dispon√≠veis (n√£o esgotadas)
            const availableKeys = keyUsageArray
                .filter(key => key.count < 9500) // Deixar margem de seguran√ßa
                .sort((a, b) => a.count - b.count) // Ordenar por menor uso
                .map(key => key.index);
            
            if (availableKeys.length === 0) {
                console.log('‚ö†Ô∏è Todas as chaves esgotaram suas cotas!');
                return null;
            }
            
            // Usar a primeira chave dispon√≠vel com menor uso
            currentKeyIndex = parseInt(availableKeys[0]);
            
            // N√ÉO incrementar aqui - ser√° incrementado apenas em caso de sucesso
            console.log(`üîë Tentando chave ${currentKeyIndex + 1}/${window.YOUTUBE_API_KEYS.length} (uso atual: ${keyUsageCount[currentKeyIndex]})`);
            
            return window.YOUTUBE_API_KEYS[currentKeyIndex];
        }

        // Fun√ß√£o para incrementar uso da chave atual (chamada em caso de sucesso)
        function incrementKeyUsage() {
            keyUsageCount[currentKeyIndex]++;
            console.log(`üìä Chave ${currentKeyIndex + 1} usada ${keyUsageCount[currentKeyIndex]} vezes`);
        }

        // Fun√ß√£o para marcar uma chave como esgotada
        function markApiKeyAsExhausted(apiKey) {
            const keyIndex = window.YOUTUBE_API_KEYS.indexOf(apiKey);
            if (keyIndex !== -1) {
                keyUsageCount[keyIndex] = 10000; // Marcar como esgotada (acima do limite)
                console.log(`‚ö†Ô∏è Chave ${keyIndex + 1} marcada como esgotada`);
            }
        }
        // Firebase Configuration - usando configura√ß√µes centralizadas
        let db, auth; // Declarar vari√°veis globalmente
        
        try {
            if (!validateConfig()) {
                alert('‚ùå Configura√ß√µes do Firebase inv√°lidas!');
                throw new Error('Configura√ß√µes do Firebase inv√°lidas');
            }

            // Inicializar Firebase com configura√ß√µes otimizadas
            firebase.initializeApp(window.firebaseConfig);
            db = firebase.firestore();
            
            // Configurar Firestore para evitar listeners em tempo real
            db.settings({
                cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED,
                experimentalForceLongPolling: false // Desabilita long polling que causa ERR_BLOCKED_BY_CLIENT
            });
            
            auth = firebase.auth();
            
            console.log('‚úÖ Firebase inicializado com sucesso!');
        } catch (error) {
            console.error('‚ùå Erro na inicializa√ß√£o do Firebase:', error);
            alert('‚ùå Erro na inicializa√ß√£o do Firebase: ' + error.message);
            throw error;
        }

        let creditsUsed = 0;
        let processedSongs = 0;
        let currentBatchNumber = 0;

        // Elementos DOM
        const elements = {
            totalAvailable: document.getElementById('totalAvailable'),
            totalBatches: document.getElementById('totalBatches'),
            currentBatch: document.getElementById('currentBatch'),
            processedSongs: document.getElementById('processedSongs'),
            creditsUsed: document.getElementById('creditsUsed'),
            creditsRemaining: document.getElementById('creditsRemaining'),
            batchSelect: document.getElementById('batchSelect'),
            populateBatchBtn: document.getElementById('populateBatchBtn'),
            testConnectionBtn: document.getElementById('testConnectionBtn'),
            clearLogBtn: document.getElementById('clearLogBtn'),
            viewBatchBtn: document.getElementById('viewBatchBtn'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            logContainer: document.getElementById('logContainer')
        };

        // Fun√ß√£o para adicionar log
        function addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            elements.logContainer.appendChild(logEntry);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
        }

        // Fun√ß√£o para atualizar estat√≠sticas
        function updateStats() {
            const totalAvailable = getTotalAvailableMusic();
            const totalBatches = getTotalBatches();
            
            elements.totalAvailable.textContent = totalAvailable.toLocaleString();
            elements.totalBatches.textContent = totalBatches;
            elements.currentBatch.textContent = currentBatchNumber + 1;
            elements.processedSongs.textContent = processedSongs;
            elements.creditsUsed.textContent = creditsUsed.toLocaleString();
            elements.creditsRemaining.textContent = (60000 - creditsUsed).toLocaleString();
        }

        // Fun√ß√£o para atualizar display de cr√©ditos
        function updateCreditsDisplay() {
            elements.creditsUsed.textContent = creditsUsed.toLocaleString();
            elements.creditsRemaining.textContent = (60000 - creditsUsed).toLocaleString();
        }

        // Fun√ß√£o para popular seletor de lotes
        function populateBatchSelector() {
            const totalBatches = getTotalBatches();
            elements.batchSelect.innerHTML = '';
            
            for (let i = 0; i < totalBatches; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Lote ${i + 1} (M√∫sicas ${i * 100 + 1}-${Math.min((i + 1) * 100, getTotalAvailableMusic())})`;
                elements.batchSelect.appendChild(option);
            }
        }

        // Fun√ß√£o para buscar v√≠deo no YouTube (fun√ß√£o legada - mantida para compatibilidade)
        async function searchYouTubeVideo(title, artist) {
            const query = `${title} ${artist} karaoke playback instrumental`.replace(/[^\w\s]/gi, '');
            
            // Tentar at√© 3 vezes com chaves diferentes
            for (let attempt = 0; attempt < 3; attempt++) {
                const apiKey = getNextAPIKey();
                
                if (!apiKey) {
                    throw new Error('Nenhuma chave de API dispon√≠vel');
                }
                
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${apiKey}&maxResults=1`;

                try {
                    const response = await fetch(url);
                    const data = await response.json();

                    if (response.status === 403 || (data.error && data.error.code === 403)) {
                        addLog(`‚ö†Ô∏è Chave API ${currentKeyIndex + 1} esgotada, tentando pr√≥xima...`, 'warning');
                        markApiKeyAsExhausted(apiKey);
                        continue; // Tentar pr√≥xima chave
                    }

                    if (data.items && data.items.length > 0) {
                        const video = data.items[0];
                        incrementKeyUsage(); // Incrementar uso em caso de sucesso
                        creditsUsed += 100; // Cada busca custa 100 cr√©ditos
                        return {
                            videoId: video.id.videoId,
                            publishedAt: video.snippet.publishedAt,
                            thumbnail: video.snippet.thumbnails.medium?.url || './THUMBNAIL.JPG'
                        };
                    }

                    return null;
                } catch (error) {
                    addLog(`‚ùå Erro na busca do YouTube (tentativa ${attempt + 1}): ${error.message}`, 'error');
                    if (attempt === 2) { // √öltima tentativa
                        return null;
                    }
                }
            }
            
            return null;
        }

        // Fun√ß√£o para popular lote
        async function populateBatch() {
            const batchNumber = parseInt(elements.batchSelect.value);
            const batch = getMusicBatch(batchNumber);
            
            if (batch.length === 0) {
                addLog('‚ùå Lote selecionado est√° vazio!', 'error');
                return;
            }

            elements.populateBatchBtn.disabled = true;
            addLog(`üöÄ Iniciando popula√ß√£o do Lote ${batchNumber + 1} (${batch.length} m√∫sicas)`, 'info');

            let processed = 0;
            let successful = 0;
            let skipped = 0;

            for (const song of batch) {
                try {
                    // Verificar se a m√∫sica j√° existe
                    const exists = await checkSongExists(song.title, song.artist);
                    if (exists) {
                        addLog(`‚è≠Ô∏è M√∫sica j√° existe: ${song.title} - ${song.artist}`, 'warning');
                        skipped++;
                        processed++;
                        continue;
                    }

                    // Buscar dados do YouTube
                    addLog(`üîç Buscando: ${song.title} - ${song.artist}`, 'info');
                    const youtubeData = await searchYouTubeVideo(song.title, song.artist);

                    // Preparar dados da m√∫sica
                    const songData = {
                        title: song.title,
                        artist: song.artist,
                        genre: song.genre,
                        searchTerm: song.searchTerm,
                        videoId: youtubeData?.videoId || null,
                        publishedAt: youtubeData?.publishedAt || null,
                        thumbnail: './THUMBNAIL.JPG',
                        addedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        source: 'batch-populate'
                    };

                    // Salvar no Firebase
                    await db.collection('songs').add(songData);
                    
                    // Atualizar cache local para evitar consultas desnecess√°rias
                    if (existingSongsCache) {
                        const normalizedTitle = song.title.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                        const normalizedArtist = song.artist.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                        existingSongsCache.add(`${normalizedTitle}|${normalizedArtist}`);
                    }
                    
                    addLog(`‚úÖ Salva: ${song.title} - ${song.artist}`, 'success');
                    successful++;

                    // Delay para n√£o sobrecarregar a API
                    await new Promise(resolve => setTimeout(resolve, 1200));

                } catch (error) {
                    addLog(`‚ùå Erro ao processar ${song.title}: ${error.message}`, 'error');
                }

                processed++;
                processedSongs++;

                // Atualizar progresso
                const progress = (processed / batch.length) * 100;
                elements.progressFill.style.width = `${progress}%`;
                elements.progressText.textContent = `Processando: ${processed}/${batch.length} m√∫sicas`;
                updateStats();
            }

            // Finalizar
            elements.progressFill.style.width = '100%';
            elements.progressText.textContent = 'Popula√ß√£o conclu√≠da!';
            elements.populateBatchBtn.disabled = false;

            addLog(`üéâ Lote ${batchNumber + 1} conclu√≠do! Sucessos: ${successful}, Ignoradas: ${skipped}, Cr√©ditos gastos: ${creditsUsed}`, 'success');
        }

        // Cache local para evitar consultas repetidas ao Firebase
        let existingSongsCache = null;
        let cacheTimestamp = null;
        const BATCH_CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

        // Fun√ß√£o para carregar cache de m√∫sicas existentes
        async function loadExistingSongsCache() {
            try {
                // Verificar se o cache ainda √© v√°lido
                if (existingSongsCache && cacheTimestamp && (Date.now() - cacheTimestamp < BATCH_CACHE_DURATION)) {
                    return existingSongsCache;
                }

                addLog('üì¶ Carregando cache de m√∫sicas existentes...', 'info');
                const songsRef = db.collection('songs');
                const snapshot = await songsRef.get();
                
                existingSongsCache = new Set();
                snapshot.docs.forEach(doc => {
                    const songData = doc.data();
                    const normalizedTitle = songData.title.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                    const normalizedArtist = songData.artist.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                    existingSongsCache.add(`${normalizedTitle}|${normalizedArtist}`);
                });
                
                cacheTimestamp = Date.now();
                addLog(`‚úÖ Cache carregado: ${existingSongsCache.size} m√∫sicas`, 'success');
                return existingSongsCache;
            } catch (error) {
                console.error('Erro ao carregar cache:', error);
                return new Set();
            }
        }

        // Fun√ß√£o otimizada para verificar se m√∫sica j√° existe
        async function checkSongExists(title, artist) {
            try {
                const cache = await loadExistingSongsCache();
                const normalizedTitle = title.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                const normalizedArtist = artist.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\w\s]/g, '').trim();
                
                return cache.has(`${normalizedTitle}|${normalizedArtist}`);
            } catch (error) {
                console.error('Erro ao verificar duplicata:', error);
                return false;
            }
        }

        // Fun√ß√£o para testar conex√£o
        async function testConnection() {
            try {
                addLog('üîó Testando conex√£o com Firebase...', 'info');
                await auth.signInAnonymously();
                
                const testDoc = await db.collection('songs').limit(1).get();
                addLog(`‚úÖ Conex√£o OK! ${testDoc.size} documento(s) encontrado(s)`, 'success');
            } catch (error) {
                addLog(`‚ùå Erro de conex√£o: ${error.message}`, 'error');
            }
        }

        // Fun√ß√£o para visualizar lote
        function viewBatch() {
            const batchNumber = parseInt(elements.batchSelect.value);
            const batch = getMusicBatch(batchNumber);
            
            addLog(`üëÅÔ∏è Visualizando Lote ${batchNumber + 1}:`, 'info');
            batch.slice(0, 10).forEach((song, index) => {
                addLog(`${index + 1}. ${song.title} - ${song.artist} (${song.genre})`, 'info');
            });
            
            if (batch.length > 10) {
                addLog(`... e mais ${batch.length - 10} m√∫sicas`, 'info');
            }
        }

        // Event Listeners
        elements.populateBatchBtn.addEventListener('click', populateBatch);
        elements.testConnectionBtn.addEventListener('click', testConnection);
        elements.clearLogBtn.addEventListener('click', () => {
            elements.logContainer.innerHTML = '<div class="log-entry log-info">üßπ Log limpo - Sistema pronto!</div>';
        });
        elements.viewBatchBtn.addEventListener('click', viewBatch);
        elements.batchSelect.addEventListener('change', (e) => {
            currentBatchNumber = parseInt(e.target.value);
            updateStats();
        });

        // üé∏ NOVO EVENT LISTENER: Busca de Cl√°ssicos
        document.getElementById('searchClassicsBtn').addEventListener('click', searchExpandedClassics);
        
        // Event listener para limpar cache da sess√£o
        document.getElementById('clearSessionCacheBtn').addEventListener('click', clearSessionCache);

        // üé∏ SISTEMA DE BUSCA DE CL√ÅSSICOS POR D√âCADA E G√äNERO
        
        // Termos de busca organizados por d√©cada e g√™nero
        const SEARCH_TERMS_BY_DECADE = {
            '1960s': {
                rock: ['classic rock 60s karaoke', 'rock and roll 1960s karaoke', 'beatles karaoke playback', 'rolling stones 60s karaoke', 'rock cl√°ssico anos 60 karaoke'],
                sertanejo: ['sertanejo raiz anos 60 karaoke', 'moda de viola 60s karaoke playback', 'sertanejo cl√°ssico 1960 karaoke', 'duplas sertanejas 60s karaoke', 'viola caipira 60s karaoke'],
                romantico: ['rom√¢nticas anos 60 karaoke', 'love songs 1960s karaoke', 'baladas rom√¢nticas 60s karaoke playback', 'm√∫sica rom√¢ntica 60s karaoke', 'slow 60s karaoke'],
                mpb: ['mpb anos 60 karaoke', 'bossa nova 60s karaoke', 'm√∫sica popular brasileira 1960 karaoke playback', 'tropic√°lia 60s karaoke', 'mpb cl√°ssica 60s karaoke']
            },
            '1970s': {
                rock: ['classic rock 70s karaoke', 'rock progressivo 70s karaoke', 'hard rock 1970s karaoke playback', 'rock nacional 70s karaoke', 'rock cl√°ssico anos 70 karaoke'],
                sertanejo: ['sertanejo anos 70 karaoke', 'moda de viola 70s karaoke playback', 'sertanejo raiz 1970 karaoke', 'duplas sertanejas 70s karaoke', 'm√∫sica caipira 70s karaoke'],
                romantico: ['rom√¢nticas anos 70 karaoke', 'love songs 1970s karaoke', 'baladas rom√¢nticas 70s karaoke playback', 'm√∫sica rom√¢ntica 70s karaoke', 'slow 70s karaoke'],
                mpb: ['mpb anos 70 karaoke', 'm√∫sica popular brasileira 1970 karaoke playback', 'mpb cl√°ssica 70s karaoke', 'cantores mpb 70s karaoke', 'compositores mpb 70s karaoke']
            },
            '1980s': {
                rock: ['rock 80s karaoke', 'new wave 80s karaoke', 'rock nacional 80s karaoke', 'hard rock 1980s karaoke playback', 'rock cl√°ssico anos 80 karaoke'],
                sertanejo: ['sertanejo anos 80 karaoke', 'sertanejo rom√¢ntico 80s karaoke playback', 'duplas sertanejas 80s karaoke', 'm√∫sica sertaneja 1980 karaoke', 'country brasileiro 80s karaoke'],
                romantico: ['rom√¢nticas anos 80 karaoke', 'love songs 1980s karaoke', 'baladas rom√¢nticas 80s karaoke playback', 'm√∫sica rom√¢ntica 80s karaoke', 'slow 80s karaoke'],
                mpb: ['mpb anos 80 karaoke', 'm√∫sica popular brasileira 1980 karaoke playback', 'rock nacional 80s karaoke', 'cantores mpb 80s karaoke', 'mpb rom√¢ntica 80s karaoke']
            },
            '1990s': {
                rock: ['rock 90s karaoke', 'grunge 90s karaoke', 'rock nacional 90s karaoke', 'alternative rock 1990s karaoke playback', 'rock cl√°ssico anos 90 karaoke'],
                sertanejo: ['sertanejo anos 90 karaoke', 'sertanejo rom√¢ntico 90s karaoke playback', 'duplas sertanejas 90s karaoke', 'm√∫sica sertaneja 1990 karaoke', 'country brasileiro 90s karaoke'],
                romantico: ['rom√¢nticas anos 90 karaoke', 'love songs 1990s karaoke', 'baladas rom√¢nticas 90s karaoke playback', 'm√∫sica rom√¢ntica 90s karaoke', 'slow 90s karaoke'],
                mpb: ['mpb anos 90 karaoke', 'm√∫sica popular brasileira 1990 karaoke playback', 'rock nacional 90s karaoke', 'cantores mpb 90s karaoke', 'mpb contempor√¢nea 90s karaoke']
            },
            '2000s': {
                rock: ['rock 2000s karaoke', 'nu metal 2000s karaoke', 'rock nacional 2000 karaoke', 'alternative rock 2000s karaoke playback', 'rock anos 2000 karaoke'],
                sertanejo: ['sertanejo anos 2000 karaoke', 'sertanejo universit√°rio 2000s karaoke playback', 'duplas sertanejas 2000 karaoke', 'm√∫sica sertaneja 2000 karaoke', 'sertanejo moderno 2000s karaoke'],
                romantico: ['rom√¢nticas anos 2000 karaoke', 'love songs 2000s karaoke', 'baladas rom√¢nticas 2000 karaoke playback', 'm√∫sica rom√¢ntica 2000s karaoke', 'slow 2000s karaoke'],
                mpb: ['mpb anos 2000 karaoke', 'm√∫sica popular brasileira 2000 karaoke playback', 'cantores mpb 2000s karaoke', 'mpb contempor√¢nea 2000 karaoke', 'nova mpb 2000s karaoke']
            }
        };

        // Cache global para m√∫sicas j√° processadas nesta sess√£o
        let sessionProcessedSongs = new Set();
        
        // Fun√ß√£o para criar chave √∫nica da m√∫sica (compat√≠vel com prevent-duplicates.js)
        function createSessionSongKey(title, artist) {
            const normalize = (str) => str.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/[^\w\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            return `${normalize(title)}_${normalize(artist)}`;
        }
        
        // Fun√ß√£o para verificar se m√∫sica j√° foi processada nesta sess√£o
        function isAlreadyProcessedInSession(title, artist, videoId) {
            const songKey = createSessionSongKey(title, artist);
            
            // Verificar por chave de t√≠tulo/artista
            if (sessionProcessedSongs.has(songKey)) {
                return { processed: true, reason: 'session_title_artist' };
            }
            
            // Verificar por videoId
            if (videoId && sessionProcessedSongs.has(`video_${videoId}`)) {
                return { processed: true, reason: 'session_video_id' };
            }
            
            return { processed: false };
        }
        
        // Fun√ß√£o para marcar m√∫sica como processada nesta sess√£o
        function markAsProcessedInSession(title, artist, videoId) {
            const songKey = createSessionSongKey(title, artist);
            sessionProcessedSongs.add(songKey);
            
            if (videoId) {
                sessionProcessedSongs.add(`video_${videoId}`);
            }
        }
        
        // Fun√ß√£o para limpar cache da sess√£o
        function clearSessionCache() {
            sessionProcessedSongs.clear();
            addLog('üßπ Cache da sess√£o limpo', 'info');
        }
        
        // Fun√ß√£o para mapear g√™nero selecionado para categoria do banco
        function mapGenreToCategory(genre, decade) {
            const genreMap = {
                'rock': decade < '1990s' ? 'Rock Internacional' : 'Rock Nacional',
                'sertanejo': 'Sertanejo',
                'romantico': 'Rom√¢ntico',
                'mpb': 'MPB'
            };
            return genreMap[genre] || 'Outros';
        }

        // Fun√ß√£o principal de busca de cl√°ssicos
        async function searchExpandedClassics() {
            const decade = document.getElementById('decadeSelect').value;
            const genre = document.getElementById('genreSelect').value;
            const quantity = parseInt(document.getElementById('quantitySelect').value);
            
            const searchBtn = document.getElementById('searchClassicsBtn');
            const progressDiv = document.getElementById('classicsProgress');
            const progressFill = document.getElementById('classicsProgressFill');
            const progressText = document.getElementById('classicsProgressText');
            
            // Desabilitar bot√£o e mostrar progresso
            searchBtn.disabled = true;
            progressDiv.style.display = 'block';
            
            addLog(`üé∏ Iniciando busca de cl√°ssicos: ${genre.toUpperCase()} dos ${decade} (${quantity} m√∫sicas)`, 'info');
            
            try {
                const searchTerms = SEARCH_TERMS_BY_DECADE[decade][genre];
                const targetGenre = mapGenreToCategory(genre, decade);
                
                let foundSongs = [];
                let processed = 0;
                let duplicatesFound = 0;
                
                // Buscar com cada termo
                for (let termIndex = 0; termIndex < searchTerms.length && foundSongs.length < quantity; termIndex++) {
                    const searchTerm = searchTerms[termIndex];
                    
                    progressText.textContent = `Buscando com termo: "${searchTerm}"...`;
                    addLog(`üîç Buscando: "${searchTerm}"`, 'info');
                    
                    try {
                        // Buscar no YouTube
                        const searchResults = await searchYouTubeVideos(searchTerm, Math.min(50, quantity - foundSongs.length));
                        
                        // Processar cada resultado
                        for (const video of searchResults) {
                            if (foundSongs.length >= quantity) break;
                            
                            processed++;
                            const progress = Math.min((processed / (quantity * 1.5)) * 100, 95);
                            progressFill.style.width = `${progress}%`;
                            
                            // Extrair t√≠tulo e artista do t√≠tulo do v√≠deo
                            const { title, artist } = parseVideoTitle(video.snippet.title);
                            
                            if (!title || !artist || artist === 'Artista Desconhecido') {
                                continue;
                            }
                            
                            // Verificar se j√° foi processada nesta sess√£o
                            const sessionCheck = isAlreadyProcessedInSession(title, artist, video.id.videoId);
                            if (sessionCheck.processed) {
                                addLog(`üîÑ J√° processada nesta sess√£o: "${title}" - "${artist}" (${sessionCheck.reason})`, 'info');
                                continue;
                            }
                            
                            // Verificar duplicatas com sistema avan√ßado
                            const duplicateCheck = await songExistsAdvanced(db, title, artist, video.id.videoId);
                            
                            if (duplicateCheck.exists) {
                                duplicatesFound++;
                                addLog(`‚è≠Ô∏è Duplicata ignorada: "${title}" - "${artist}" (${duplicateCheck.reason})`, 'warning');
                                // Marcar como processada mesmo sendo duplicata para evitar verifica√ß√µes futuras
                                markAsProcessedInSession(title, artist, video.id.videoId);
                                continue;
                            }
                            
                            // Marcar como processada nesta sess√£o
                            markAsProcessedInSession(title, artist, video.id.videoId);
                            
                            // Adicionar √† lista de m√∫sicas encontradas
                            const songData = {
                                title: title,
                                artist: artist,
                                genre: targetGenre,
                                searchTerm: searchTerm,
                                videoId: video.id.videoId,
                                publishedAt: video.snippet.publishedAt,
                                thumbnail: './THUMBNAIL.JPG',
                                addedAt: new Date().toISOString(),
                                source: 'classics_search'
                            };
                            
                            foundSongs.push(songData);
                            addLog(`‚úÖ Encontrada: "${title}" - "${artist}" (${targetGenre})`, 'success');
                        }
                        
                    } catch (error) {
                        addLog(`‚ùå Erro na busca "${searchTerm}": ${error.message}`, 'error');
                    }
                    
                    // Pequeno delay entre buscas
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Salvar m√∫sicas no Firebase usando batch operations
                if (foundSongs.length > 0) {
                    progressText.textContent = `Salvando ${foundSongs.length} m√∫sicas no banco...`;
                    
                    let savedCount = 0;
                    const batchSize = 500; // Firestore batch limit
                    
                    for (let i = 0; i < foundSongs.length; i += batchSize) {
                        const batch = db.batch();
                        const batchSongs = foundSongs.slice(i, i + batchSize);
                        
                        batchSongs.forEach(song => {
                            const docRef = db.collection('songs').doc();
                            batch.set(docRef, song);
                        });
                        
                        try {
                            await batch.commit();
                            savedCount += batchSongs.length;
                            
                            const saveProgress = 95 + ((savedCount / foundSongs.length) * 5);
                            progressFill.style.width = `${saveProgress}%`;
                            
                            addLog(`‚úÖ Lote salvo: ${batchSongs.length} m√∫sicas (${savedCount}/${foundSongs.length})`, 'success');
                            
                        } catch (error) {
                            addLog(`‚ùå Erro ao salvar lote: ${error.message}`, 'error');
                        }
                    }
                    
                    // Finalizar
                    progressFill.style.width = '100%';
                    progressText.textContent = `Conclu√≠do! ${savedCount} m√∫sicas adicionadas`;
                    
                    addLog(`üéâ Busca de cl√°ssicos conclu√≠da!`, 'success');
                    addLog(`üìä Resultados: ${savedCount} salvas, ${duplicatesFound} duplicatas ignoradas`, 'info');
                    
                    // Atualizar estat√≠sticas
                    updateStats();
                    
                } else {
                    addLog(`‚ö†Ô∏è Nenhuma m√∫sica nova encontrada para os crit√©rios selecionados`, 'warning');
                    progressText.textContent = 'Nenhuma m√∫sica nova encontrada';
                }
                
            } catch (error) {
                addLog(`‚ùå Erro geral na busca de cl√°ssicos: ${error.message}`, 'error');
                progressText.textContent = 'Erro na busca';
            } finally {
                // Reabilitar bot√£o
                searchBtn.disabled = false;
                
                // Ocultar progresso ap√≥s 5 segundos
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    progressFill.style.width = '0%';
                }, 5000);
            }
        }

        // Fun√ß√£o auxiliar para buscar v√≠deos no YouTube (reutiliza a l√≥gica existente)
        async function searchYouTubeVideos(searchTerm, maxResults = 50) {
            // Tentar at√© 3 vezes com chaves diferentes
            for (let attempt = 0; attempt < 3; attempt++) {
                const apiKey = getNextAPIKey();
                if (!apiKey) {
                    throw new Error('Nenhuma chave de API dispon√≠vel');
                }
                
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchTerm)}&type=video&maxResults=${maxResults}&key=${apiKey}`;
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.error) {
                        if (data.error.code === 403) {
                            addLog(`‚ö†Ô∏è Chave API ${currentKeyIndex + 1} esgotada, tentando pr√≥xima...`, 'warning');
                            markApiKeyAsExhausted(apiKey);
                            continue; // Tentar pr√≥xima chave
                        }
                        throw new Error(data.error.message);
                    }
                    
                    // Incrementar contador de cr√©ditos
                    creditsUsed += maxResults;
                    updateCreditsDisplay();
                    
                    // Incrementar uso da chave em caso de sucesso
                    incrementKeyUsage();
                    
                    return data.items || [];
                } catch (error) {
                    addLog(`‚ùå Erro na busca (tentativa ${attempt + 1}): ${error.message}`, 'error');
                    if (attempt === 2) { // √öltima tentativa
                        throw error;
                    }
                }
            }
            
            throw new Error('Todas as tentativas de busca falharam');
        }

        // Inicializa√ß√£o
        document.addEventListener('DOMContentLoaded', () => {
            populateBatchSelector();
            updateStats();
            addLog('üéµ Sistema de Popula√ß√£o por Lotes carregado e pronto!', 'success');
            
            // Autentica√ß√£o autom√°tica
            auth.signInAnonymously().then(() => {
                addLog('üîê Autentica√ß√£o Firebase realizada com sucesso!', 'success');
            }).catch(error => {
                addLog(`‚ùå Erro na autentica√ß√£o: ${error.message}`, 'error');
            });
        });
    </script>
</body>
</html>